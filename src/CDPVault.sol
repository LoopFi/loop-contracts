// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {IBuffer} from "./interfaces/IBuffer.sol";
import {ICDM} from "./interfaces/ICDM.sol";
import {ICDPVaultBase, CDPVaultConstants, CDPVaultConfig} from "./interfaces/ICDPVault.sol";
import {IOracle} from "./interfaces/IOracle.sol";

import {WAD, toInt256, toUint64, max, min, add, sub, wmul, wdiv, wmulUp} from "./utils/Math.sol";
import {Permission} from "./utils/Permission.sol";
import {Pause, PAUSER_ROLE} from "./utils/Pause.sol";

import {getCredit, getDebt, getCreditLine} from "./CDM.sol";
import {InterestRateModel} from "./InterestRateModel.sol";

import {IChefIncentivesController} from "./reward/interfaces/IChefIncentivesController.sol";

// Authenticated Roles
bytes32 constant VAULT_CONFIG_ROLE = keccak256("VAULT_CONFIG_ROLE");
bytes32 constant VAULT_UNWINDER_ROLE = keccak256("VAULT_UNWINDER_ROLE");

/// @notice Calculates the actual debt from a normalized debt amount
/// @param normalDebt Normalized debt (either of a position or the total normalized debt)
/// @param rateAccumulator Rate accumulator
/// @return debt Actual debt [wad]
function calculateDebt(
    uint256 normalDebt,
    uint64 rateAccumulator
) pure returns (uint256 debt) {
    debt = wmul(normalDebt, rateAccumulator);
}

/// @notice Calculates the normalized debt from an actual debt amount
/// @param debt Actual debt (either of a position or the total debt)
/// @param rateAccumulator Rate accumulator
/// @return normalDebt Normalized debt [wad]
function calculateNormalDebt(
    uint256 debt,
    uint64 rateAccumulator
) pure returns (uint256 normalDebt) {
    normalDebt = wdiv(debt, rateAccumulator);

    // account for rounding errors due to division
    if (calculateDebt(normalDebt, rateAccumulator) < debt) {
        unchecked { ++normalDebt; }
    }
}

/// @title CDPVault
/// @notice Base logic of a borrow vault for depositing collateral and drawing credit against it
contract CDPVault is AccessControl, Pause, Permission, InterestRateModel, ICDPVaultBase {

    /*//////////////////////////////////////////////////////////////
                               LIBRARIES
    //////////////////////////////////////////////////////////////*/

    using SafeERC20 for IERC20;

    /*//////////////////////////////////////////////////////////////
                               CONSTANTS
    //////////////////////////////////////////////////////////////*/

    // CDPVault Parameters
    /// @notice CDM (Credit and Debt Manager)
    ICDM public immutable cdm;
    /// @notice Oracle of the collateral token
    IOracle public immutable oracle;
    /// @notice Global surplus and debt Buffer
    IBuffer public immutable buffer;
    /// @notice collateral token
    IERC20 public immutable token;
    /// @notice Collateral token's decimals scale (10 ** decimals)
    uint256 public immutable tokenScale;

    /*//////////////////////////////////////////////////////////////
                                STORAGE
    //////////////////////////////////////////////////////////////*/

    struct VaultConfig {
        /// @notice Min. amount of debt that has to be generated by a position [wad]
        uint128 debtFloor;
        /// @notice Collateralization ratio below which a position can be liquidated [wad]
        uint64 liquidationRatio;
    }
    /// @notice CDPVault configuration
    VaultConfig public vaultConfig;

    // CDPVault Accounting
    /// @notice Sum of backed normalized debt over all positions [wad]
    uint256 public totalNormalDebt;

    // Cash Accounting
    /// @notice Map specifying the cash balances a user has [wad]
    mapping(address owner => uint256 balance) public cash;

    // Position Accounting
    struct Position {
        uint256 collateral; // [wad]
        uint256 normalDebt; // [wad]
    }
    /// @notice Map of user positions
    mapping(address owner => Position) public positions;

    struct LiquidationConfig {
        // is subtracted from the `repayAmount` to avoid profitable self liquidations [wad]
        // defined as: 1 - penalty (e.g. `liquidationPenalty` = 0.95 is a 5% penalty)
        uint64 liquidationPenalty;
        // is subtracted from the `spotPrice` of the collateral to provide incentive to liquidate unsafe positions [wad]
        // defined as: 1 - discount (e.g. `liquidationDiscount` = 0.95 is a 5% discount)
        uint64 liquidationDiscount;
    }
    /// @notice Liquidation configuration
    LiquidationConfig public liquidationConfig;

    /// @notice Reward incentives controller
    IChefIncentivesController public rewardController;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/
    
    event ModifyPosition(
        address indexed position,
        int256 deltaCollateral,
        int256 deltaNormalDebt,
        uint256 totalNormalDebt
    );
    event ModifyCollateralAndDebt(
        address indexed position,
        address indexed collateralizer,
        address indexed creditor,
        int256 deltaCollateral,
        int256 deltaNormalDebt
    );
    event SetParameter(bytes32 indexed parameter, uint256 data);
    event SetParameter(bytes32 indexed parameter, address data);
    event LiquidatePosition(
        address indexed position,
        uint256 collateralReleased,
        uint256 normalDebtRepaid,
        address indexed liquidator
    );
    event VaultCreated(address indexed vault, address indexed token, address indexed owner);


    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error CDPVault__modifyPosition_debtFloor();
    error CDPVault__modifyCollateralAndDebt_notSafe();
    error CDPVault__modifyCollateralAndDebt_noPermission();
    error CDPVault__modifyCollateralAndDebt_maxUtilizationRatio();
    error CDPVault__setParameter_unrecognizedParameter();
    error CDPVault__liquidatePosition_notUnsafe();
    error CDPVault__liquidatePosition_invalidParameters();

    /*//////////////////////////////////////////////////////////////
                             INITIALIZATION
    //////////////////////////////////////////////////////////////*/

    constructor(
        CDPVaultConstants memory constants,
        CDPVaultConfig memory config
    ) {
        cdm = constants.cdm;
        oracle = constants.oracle;
        buffer = constants.buffer;
        token = constants.token;
        tokenScale = constants.tokenScale;

        vaultConfig = VaultConfig({
            debtFloor: config.debtFloor,
            liquidationRatio: config.liquidationRatio
        });

        liquidationConfig = LiquidationConfig({
            liquidationPenalty: config.liquidationPenalty,
            liquidationDiscount: config.liquidationDiscount
        });
        
        _setIRS(IRS({
            baseRate: toUint64(config.baseRate),
            lastUpdated: toUint64(block.timestamp),
            rateAccumulator: toUint64(WAD)
        }));

        // Access Control Role Admin
        _grantRole(DEFAULT_ADMIN_ROLE, config.roleAdmin);
        _grantRole(VAULT_CONFIG_ROLE, config.vaultAdmin);
        _grantRole(PAUSER_ROLE, config.pauseAdmin);
        _grantRole(VAULT_UNWINDER_ROLE, config.vaultUnwinder);

        emit VaultCreated(address(this), address(token), config.roleAdmin);
    }

    /*//////////////////////////////////////////////////////////////
                             CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Sets various variables for this contract
    /// @dev Sender has to be allowed to call this method
    /// @param parameter Name of the variable to set
    /// @param data New value to set for the variable [wad]
    function setParameter(bytes32 parameter, uint256 data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) {
        if (parameter == "debtFloor") vaultConfig.debtFloor = uint128(data);
        else if (parameter == "liquidationRatio") vaultConfig.liquidationRatio = uint64(data);
        else if (parameter == "baseRate") _setBaseRate(uint64(data));
        else if (parameter == "liquidationPenalty") liquidationConfig.liquidationPenalty = uint64(data);
        else if (parameter == "liquidationDiscount") liquidationConfig.liquidationDiscount = uint64(data);
        else revert CDPVault__setParameter_unrecognizedParameter();
        emit SetParameter(parameter, data);
    }

    function setParameter(bytes32 parameter, address data) external whenNotPaused onlyRole(VAULT_CONFIG_ROLE) {
        if (parameter == "rewardController") rewardController = IChefIncentivesController(data);
        else revert CDPVault__setParameter_unrecognizedParameter();
        emit SetParameter(parameter, data);
    }

    /*//////////////////////////////////////////////////////////////
                      CASH BALANCE ADMINISTRATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Deposits collateral tokens into this contract and increases a users cash balance
    /// @dev The caller needs to approve this contract to transfer tokens on their behalf
    /// @param to Address of the user to attribute the cash to
    /// @param amount Amount of tokens to deposit [tokenScale]
    /// @return cashAmount Amount of cash deposited [wad]
    function deposit(address to, uint256 amount) external whenNotPaused returns (uint256 cashAmount) {
        token.safeTransferFrom(msg.sender, address(this), amount);
        cashAmount = wdiv(amount, tokenScale);
        cash[to] += cashAmount;
    }

    /// @notice Withdraws collateral tokens from this contract and decreases a users cash balance
    /// @param to Address of the user to withdraw tokens to
    /// @param amount Amount of tokens to withdraw [wad]
    /// @return tokenAmount Amount of tokens withdrawn [tokenScale]
    function withdraw(address to, uint256 amount) external whenNotPaused returns (uint256 tokenAmount) {
        cash[msg.sender] -= amount;
        tokenAmount = wmul(amount, tokenScale);
        token.safeTransfer(to, tokenAmount);
    }

    /*//////////////////////////////////////////////////////////////
                          INTEREST COLLECTION
    //////////////////////////////////////////////////////////////*/

    /// @notice Sends accrued protocol fees to the Buffer
    function collectInterest() external returns (uint256 interestCollected) {
        interestCollected = getAccruedInterest();
        _resetAccruedInterest();
        cdm.modifyBalance(address(this), address(buffer), interestCollected);
    }

    /*//////////////////////////////////////////////////////////////
                                PRICING
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns the current spot price of the collateral token
    /// @return _ Current spot price of the collateral token [wad]
    function spotPrice() public view returns (uint256) {
        return oracle.spot(address(token));
    }

    /*//////////////////////////////////////////////////////////////
                        POSITION ADMINISTRATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Updates a position's collateral and normalized debt balances
    /// @dev This is the only method which is allowed to modify a position's collateral and normalized debt balances
    function _modifyPosition(
        address owner,
        Position memory position,
        uint64 rateAccumulator,
        int256 deltaCollateral,
        int256 deltaNormalDebt,
        uint256 totalNormalDebt_
    ) internal returns (Position memory) {
        // update collateral and normalized debt amounts by the deltas
        position.collateral = add(position.collateral, deltaCollateral);
        position.normalDebt = add(position.normalDebt, deltaNormalDebt);

        // position either has no debt or more debt than the debt floor
        if (position.normalDebt != 0 
            && calculateDebt(position.normalDebt, rateAccumulator)
                < uint256(vaultConfig.debtFloor)
        ) revert CDPVault__modifyPosition_debtFloor();

        // store the position's balances
        positions[owner] = position;

        if (address(rewardController) != address(0)) {
            rewardController.handleActionAfter(owner, position.normalDebt, totalNormalDebt_);
        }

        emit ModifyPosition(owner, deltaCollateral, deltaNormalDebt, add(totalNormalDebt_, deltaNormalDebt));
    
        return position;
    }

    /// @notice Returns true if the collateral value is equal or greater than the debt
    function _isCollateralized(
        uint256 debt, uint256 collateralValue, uint256 liquidationRatio
    ) internal pure returns (bool) {
        return (wdiv(collateralValue, liquidationRatio) >= debt);
    }

    /// @notice Modifies a Position's collateral and debt balances
    /// @dev Checks that the global debt ceiling and the vault's debt ceiling have not been exceeded via the CDM,
    /// - that the Position is still safe after the modification,
    /// - that the msg.sender has the permission of the owner to decrease the collateral-to-debt ratio,
    /// - that the msg.sender has the permission of the collateralizer to put up new collateral,
    /// - that the msg.sender has the permission of the creditor to settle debt with their credit,
    /// - that that the vault debt floor is exceeded
    /// - that the vault minimum collateralization ratio is met
    /// @param owner Address of the owner of the position
    /// @param collateralizer Address of who puts up or receives the collateral delta
    /// @param creditor Address of who provides or receives the credit delta for the debt delta
    /// @param deltaCollateral Amount of collateral to put up (+) or to remove (-) from the position [wad]
    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or
    /// to settle (-) on this position [wad]
    function modifyCollateralAndDebt(
        address owner,
        address collateralizer,
        address creditor,
        int256 deltaCollateral,
        int256 deltaNormalDebt
    ) external {
        if (
            // position is either more safe than before or msg.sender has the permission from the owner
            (deltaNormalDebt > 0 || deltaCollateral < 0) && !hasPermission(owner, msg.sender)
            // msg.sender has the permission of the collateralizer to collateralize the position using their cash
            || (deltaCollateral > 0 && !hasPermission(collateralizer, msg.sender))
            // msg.sender has the permission of the creditor to use their credit to repay the debt
            || (deltaNormalDebt < 0 && !hasPermission(creditor, msg.sender))
        ) revert CDPVault__modifyCollateralAndDebt_noPermission();

        Position memory position = positions[owner];
        VaultConfig memory config = vaultConfig;
        uint256 totalNormalDebt_ = totalNormalDebt;
        uint256 spotPrice_ = spotPrice();

        // update the interest rate state
        (IRS memory irs) = _updateIRS(totalNormalDebt_);

        // update the position's balances,
        position = _modifyPosition(owner, position, irs.rateAccumulator, deltaCollateral, deltaNormalDebt, totalNormalDebt_);

        // position is either less risky than before or it is safe
        uint256 debt = calculateDebt(position.normalDebt, irs.rateAccumulator);
        uint256 collateralValue = wmul(position.collateral, spotPrice_);
        if (
            (deltaNormalDebt > 0 || deltaCollateral < 0) && !_isCollateralized(
                debt, collateralValue, config.liquidationRatio
            )
        ) revert CDPVault__modifyCollateralAndDebt_notSafe();

        // store updated collateral and normalized debt amounts
        cash[collateralizer] = sub(cash[collateralizer], deltaCollateral);
        totalNormalDebt_ = add(totalNormalDebt_, deltaNormalDebt); 
        totalNormalDebt = totalNormalDebt_;

        // update debt and credit balances in the CDM
        // pay the claimedRebate to the creditor (claimedRebate is zero if deltaNormalDebt >= 0 and positive else)
        int256 deltaDebt = wmul(irs.rateAccumulator, deltaNormalDebt);
        if (deltaDebt > 0) {
            cdm.modifyBalance(address(this), creditor, uint256(deltaDebt));
        } else if (deltaDebt < 0) {
            cdm.modifyBalance(creditor, address(this), uint256(-deltaDebt));
        }

        emit ModifyCollateralAndDebt(owner, collateralizer, creditor, deltaCollateral, deltaNormalDebt);
    }

    /*//////////////////////////////////////////////////////////////
                              LIQUIDATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Liquidates a single unsafe positions by selling collateral at a discounted (`liquidationDiscount`)
    /// oracle price. The liquidator has to provide the amount he wants to repay or sell (`repayAmounts`) for
    /// the position. From that repay amount a penalty (`liquidationPenalty`) is subtracted to mitigate against
    /// profitable self liquidations. If the available collateral of a position is not sufficient to cover the debt
    /// the vault accumulates 'bad debt'.
    /// @dev The liquidator has to approve the vault to transfer the sum of `repayAmounts`.
    /// @param owner Owner of the position to liquidate
    /// @param repayAmount Amount the liquidator wants to repay [wad]
    function liquidatePosition(address owner, uint256 repayAmount) external whenNotPaused {

        // validate params
        if (owner == address(0) || repayAmount == 0) revert CDPVault__liquidatePosition_invalidParameters();

        // load configs 
        VaultConfig memory config = vaultConfig;
        LiquidationConfig memory liqConfig_ = liquidationConfig;

        // load liquidated position, IRS and price
        Position memory position = positions[owner];
        IRS memory irs = _updateIRS(totalNormalDebt);
        uint256 spotPrice_ = spotPrice();
        uint256 discountedPrice = wmul(spotPrice_, liqConfig_.liquidationDiscount);

        // calculate position debt and collateral value
        uint256 debt = calculateDebt(position.normalDebt, irs.rateAccumulator);
        uint256 collateralValue = wmul(position.collateral, spotPrice_);

        // verify that the position is indeed unsafe
        if (spotPrice_ == 0 || _isCollateralized(
            debt, collateralValue, config.liquidationRatio
        )) revert CDPVault__liquidatePosition_notUnsafe();

        // compute collateral to take, debt to repay and penalty to pay
        uint256 takeCollateral = wdiv(repayAmount, discountedPrice);
        uint256 deltaDebt = wmul(repayAmount, liqConfig_.liquidationPenalty);
        uint256 penalty = wmul(repayAmount, WAD - liqConfig_.liquidationPenalty);

        // account for bad debt
        if (takeCollateral > position.collateral) {
            takeCollateral = position.collateral;
            repayAmount = wmul(takeCollateral, discountedPrice);
            penalty = wmul(repayAmount, WAD - liqConfig_.liquidationPenalty);
            // debt >= repayAmount if takeCollateral > position.collateral
            deltaDebt = debt;
        }
   
        // update liquidated position
        _modifyPosition(
            owner,
            position,
            irs.rateAccumulator,
            -toInt256(takeCollateral),
            -toInt256(deltaDebt),
            totalNormalDebt
        );

        // update vault state
        totalNormalDebt -= deltaDebt;

        // transfer the repay amount from the liquidator to the vault
        cdm.modifyBalance(msg.sender, address(this), repayAmount);

        // transfer the cash amount from the vault to the liquidator
        cash[msg.sender] += takeCollateral;

        // transfer the penalty from the vault to the buffer
        cdm.modifyBalance(address(this), address(buffer), penalty);
    }
}
